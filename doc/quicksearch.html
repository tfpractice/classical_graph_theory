<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"graphTheory_edge.js.html":{"id":"graphTheory_edge.js.html","title":"Source: graphTheory/edge.js","body":" DocStrap Modules graphTheory Classes graphTheory.EdgegraphTheory.EdgeArraygraphTheory.GraphgraphTheory.NodegraphTheory.NodeArray Global Global Source: graphTheory/edge.js var Node = require('./node'); var NodeArray = require('./nodeArray'); /** * represents a connection between nodes * @exports Edge * @constructor * @memberOf! module:graphTheory */ class Edge { constructor(n1 = new Node(), n2 = new Node(), weight = 0) { /** * an array of nodes * @type {NodeArray} */ this.nodes = NodeArray.of(n1, n2); /** * the weight of the edge * @type {Number} */ this.weight = weight; /** * an identifier for the Edge * @type {String} */ this.setLabel(); } setLabel() { this.label = `${this.nodes[0].label}_${this.nodes[1].label}`; } /** * checks the equivalence (by label)of this edge against another * @param {Edge} edgeArg edge to be checked * @return {Boolean} */ isEquivalent(edgeArg) { return this.hasSameNodes(edgeArg); } /** * checks the equivalence (by label)of this edge against another * @param {Edge} edgeArg edge to be checked * @return {Boolean} */ hasSameName(edgeArg) { return (this.label) ? this.label === edgeArg.label : false; } /** * checks the equivalence of this edges nodes against another * @param {Edge} edgeArg edge to be checked * @return {Boolean} */ hasSameNodes(edgeArg) { return this.nodes.isSubset(edgeArg.nodes); } /** * Checks for presence fo a node in this edge * @param {Node} nodeArg * @return {Node} */ containsNode(nodeArg) { return this.nodes.contains(nodeArg); } /** * returns the neighboring node * @param {Node} nodeArg * @return {Node} the neighbor */ getNeighbor(nodeArg) { return this.nodes.find(currNode =&gt; currNode != nodeArg); } excludeNode(nodeArg) { return this.nodes.nodeComplement(nodeArg); } } module.exports = Edge; /** * [An Edge]{@link module:graphTheory.Edge} * @typedef {module:graphTheory.Edge} Edge */ × Search results Close "},"graphTheory_edgeArray.js.html":{"id":"graphTheory_edgeArray.js.html","title":"Source: graphTheory/edgeArray.js","body":" DocStrap Modules graphTheory Classes graphTheory.EdgegraphTheory.EdgeArraygraphTheory.GraphgraphTheory.NodegraphTheory.NodeArray Global Global Source: graphTheory/edgeArray.js var Node = require('./node'); var NodeArray = require('./nodeArray'); var Edge = require('./edge'); var DirectedEdge = require('./directedEdge'); /** * represents a set of Edges * @exports EdgeArray * @constructor * @memberOf! module:graphTheory */ class EdgeArray extends Array { /** * checks for presence of edge in this set * @param {Edge} argEdge [description] * @return {Boolean} */ contains(argEdge) { return this.some(el =&gt; el.isEquivalent(argEdge)); } /** * checks type of argument for Edge status * @param {Edge} argEdge * @return {Boolean} */ isEdge(argEdge) { return argEdge instanceof Edge; } /** * adds a edge to this set * @param {Edge} argEdge * @return {Boolean} */ push(argEdge) { if (this.isEdge(argEdge) &amp;&amp; !this.contains(argEdge)) { super.push(argEdge); } return this; } /** * assembles each edges nodes into one large array * @return {NodeArray} */ getNodes() { return this.reduce((nArray, e) =&gt; { nArray.unionize(e.nodes); return nArray; }, new NodeArray()); } getNeighbors(nodeArg) { return this.edgesWithNode(nodeArg).reduce((nArray, e) =&gt; nArray.push(e.getNeighbor(nodeArg)), new NodeArray()); } /** * returns an array shared edges between two sets * @param {EdgeArray} altArray the array to check * @return {EdgeArray} the shared edges */ intersection(altArray) { return this.filter(currEdge =&gt; altArray.contains(currEdge) === true); } /** * checks for presence of shared edges between two sets * @param {EdgeArray} altArray the array to check * @return {Boolean} */ intersects(altArray) { return this.some(currEdge =&gt; altArray.contains(currEdge) === true); } /** * returns an array edges in this array not included in the alternate array * @param {EdgeArray} altArray the array to check * @return {EdgeArray} the unshared edges */ difference(altArray) { return this.filter(e =&gt; !altArray.contains(e)); } /** * checks for presence of unshared edges between two sets * @param {EdgeArray} altArray the array to check * @return {Boolean} */ hasDistinctEdges(altArray) { return this.some(myEdge =&gt; !altArray.contains(myEdge)); } hasSameSize(altArray) { return this.length === altArray.length; } isSubset(altArray) { return this.every(myEdge =&gt; altArray.contains(myEdge)); } isEquivalent(altArray) { return this.hasSameSize(altArray) &amp;&amp; this.isSubset(altArray); } /** * returns a combined array of edges belonging to this and the alternate arrays * @param {EdgeArray} altArray the array to combine * @return {EdgeArray} the edges */ union(altArray) { let uArray = new EdgeArray(); this.forEach(currEdge =&gt; uArray.push(currEdge)); altArray.forEach(altEdge =&gt; uArray.push(altEdge)); return uArray; } /** * combines all the edges into this edgeArray * @param {EdgeArray} altArray the array to check */ unionize(altArray) { altArray.difference(this).forEach(dEdge =&gt; this.push(dEdge)); return this; } /** * forces return type to a NodeArray * @param {...[type]} args the arguments * @return {[NodeArray]} */ filter(...args) { return EdgeArray.from(super.filter(...args)); } /** * forces return type to a EdgeArray * @param {...[type]} args the arguments * @return {[EdgeArray]} */ slice(...args) { return EdgeArray.from(super.slice(...args)); } /** * forces return type to a EdgeArray * @param {...[type]} args the arguments * @return {[EdgeArray]} */ concat(...args) { return EdgeArray.from(super.concat(...args)); } /** * forces return type to a EdgeArray * @param {...[type]} args the arguments * @return {[EdgeArray]} */ splice(...args) { return EdgeArray.from(super.splice(...args)); } edgeByNodes(n1, n2) { return this.find(e =&gt; (e.containsNode(n1) &amp;&amp; e.containsNode(n2))); } edgesWithNode(nodeArg) { return this.filter(e =&gt; e.containsNode(nodeArg)); } edgesByArray(nArr) { return nArr.reduce((eArr, nNode) =&gt; eArr.unionize(this.edgesWithNode(nNode)), new EdgeArray()); } removeEdge(eArg) { let ePos = this.findIndex(e =&gt; e.isEquivalent(eArg)); return (ePos &gt; -1) ? this.splice(ePos, 1) : false; } clear() { this.splice(0); return this; } copy() { return this.slice(0); } } module.exports = EdgeArray; /** * [An EdgeArray]{@link module:graphTheory.EdgeArray} * @typedef {module:graphTheory.EdgeArray} EdgeArray */ × Search results Close "},"graphTheory_graph.js.html":{"id":"graphTheory_graph.js.html","title":"Source: graphTheory/graph.js","body":" DocStrap Modules graphTheory Classes graphTheory.EdgegraphTheory.EdgeArraygraphTheory.GraphgraphTheory.NodegraphTheory.NodeArray Global Global Source: graphTheory/graph.js var Node = require('./node'); var NodeArray = require('./nodeArray'); var Edge = require('./edge'); var EdgeArray = require('./edgeArray'); /** * represents a Graph * @exports Graph * @constructor * @memberOf! module:graphTheory */ class Graph { constructor(nodes = new NodeArray()) { /** * the graph's nodes * @type {NodeArray} */ this.nodes = nodes; /** * the graph's edges * @type {EdgeArray} */ this.edges = new EdgeArray(); /** * the graph's components * @type {Component[]} */ this.components = []; } /** * adds a node to the nodes array, if not already contained * @param {Node} node the new node */ addNode(node) { this.nodes.push(node); } containsNode(argNode) { return this.nodes.contains(argNode); } removeNode(nodeArg) { this.edgesWithNode(nodeArg).forEach(e =&gt; this.removeEdge(e)); this.nodes.removeNode(nodeArg); } clearNodes() { this.nodes.forEach(n =&gt; this.removeNode(n)); this.nodes.clear(); } setNodes(nArr) { this.clearNodes(); this.nodes = nArr; } copyNodes(nArr) { this.nodes.unionize(nArr); } /** * @param {Node} nodeArg source node * @return {Edge[]} the edges connected to source */ edgesWithNode(nodeArg) { return this.edges.edgesWithNode(nodeArg); } /** * creates a new edge given two nodes * @param {Node} sNode source node * @param {Node} dNode destination node * @param {Number} weight weight of new edge */ createEdge(sNode, dNode, weight) { let tempEdge = new Edge(sNode, dNode, weight); this.addEdge(tempEdge); return tempEdge; } addEdge(edgeArg) { this.copyNodes(edgeArg.nodes); this.edges.push(edgeArg); } containsEdge(argEdge) { return this.edges.contains(argEdge); } removeEdge(argEdge) { this.edges.removeEdge(argEdge); } clearEdges() { this.edges.clear(); } setEdges(eArr) { let eNodes = eArr.getNodes(); this.setNodes(eNodes); this.edges = eArr; } copyEdges(eArr) { let eNodes = eArr.getNodes(); this.copyNodes(eNodes); this.edges.unionize(eArr); } subGraphByEdges(eArr) { let newGraph = new Graph(); newGraph.copyEdges(eArr); return newGraph; } subGraphByNodes(nArr) { return new Graph(nArr); } /** * * @param {Node} nodeArg the source node * @return {Node[]} the neighboring nodes */ getNeighbors(nodeArg) { return this.edges.getNeighbors(nodeArg); } pathNodes(pathArg) { return NodeArray.from([...pathArg.keys()]); } /** * returns all of the nodes Edges which contain nodes not yet in the specified component * @param {Node} nodeArg [description] * @param {Component} compArg [description] * @return {EdgeArray} [description] */ getUnvisitedEdges(nodeArg, compArg) { let unArr = this.getUnvisitedNeighbors(nodeArg, compArg); return this.edgesWithNode(nodeArg).edgesByArray(unArr); } /** * returns all of the nodes neighbors not yet part od the component * @param {Node} nodeArg [description] * @param {Component} compArg [description] * @return {NodeArray} [description] */ getUnvisitedNeighbors(nodeArg, compArg) { return this.getNeighbors(nodeArg).difference(compArg); } /** * adds all unvisited nodes in the path to the specified component * adds each node connected to an edge to a (depth) path * @param {Map} pathArg the path to be explored * @param {Component} compArg a key value store of node's and distances */ visitPath(pathArg) { let pNodes = this.pathNodes(pathArg); let lastNode = pNodes.pop(); let nextEdges = this.getUnvisitedEdges(lastNode, pNodes); if (nextEdges.length === 0) { return pathArg; } else { let predWeight = pathArg.get(lastNode).pathWeight; let predCount = pathArg.get(lastNode).edgeCount; nextEdges.forEach(currEdge =&gt; { let nabe = currEdge.getNeighbor(lastNode); pathArg.set(nabe, { pred: lastNode, edgeCount: predCount + 1, pathWeight: predWeight + currEdge.weight }); this.visitPath(pathArg); }); } return pathArg; } /** * depth first search, initializes a new component of reachable nodes, and constructs a path to each of those node from the source * @param {Node} initNode inital node * @return {Component} a key-value store of nodes and edge distances */ dfs(initNode) { let path = new Map(); path.set(initNode, { pred: null, edgeCount: 0, pathWeight: 0 }); this.visitPath(path); let pComp = this.pathNodes(path); this.addComponent(pComp); return path; } containsComponent(compArg) { return this.components.some(currComp =&gt; currComp.isEquivalent(compArg)) } /** * adds a component to the graph if not present * @param {Component} compArg [description] */ addComponent(compArg) { (!this.containsComponent(compArg) &amp;&amp; this.hasIntersectingComponent(compArg)) ? this.integrateComponent(compArg) : this.components.push(compArg); } removeComponent(compArg) { let cPos = this.components.findIndex(currComp =&gt; currComp.isEquivalent(compArg)); return cPos &gt; -1 ? this.components.splice(cPos, 1) : compArg; } /** * returns any current components which intersect with the specified component * @param {Component} compArg the component to be checked * @return {Component} the first intersecting component */ findIntersectingComponent(compArg) { return this.components.find(currComp =&gt; currComp.intersects(compArg)); } /** * combines the nodes of two intersecting components * @param {Component} origComp * @param {Component} newComp */ mergeComponents(origComp, newComp) { let ucomp = origComp.unionize(newComp); this.removeComponent(newComp); return ucomp; } /** * integrates a component into any of the graphs intersectung components * @param {Component} compArg [description] */ integrateComponent(compArg) { let oComp = this.findIntersectingComponent(compArg); if (oComp) this.mergeComponents(oComp, compArg); } /** * checks if any current components share nodes with the argument * @param {Component} compArg [description] * @return {Boolean} [description] */ hasIntersectingComponent(compArg) { return this.components.some(currComp =&gt; currComp.intersects(compArg)); } /** * breadth first search, recursively adds all immediate neighbors, to a component of nodes reachabe by a initial node * @param {Node} initNode inital node * @return {Map} a key-value store of nodes and edge distances */ bfs(initNode) { var bPath = new Map().set(initNode, { pred: null, pathWeight: 0, edgeCount: 0 }); var bQueue = new NodeArray(); bQueue.push(initNode); while (bQueue.length &gt; 0) { let currN = bQueue.shift(); var bNodes = this.pathNodes(bPath); let currEdges = this.getUnvisitedEdges(currN, bNodes); let prNode = bPath.get(currN); currEdges.forEach((nEdge) =&gt; { let nNode = nEdge.getNeighbor(currN); bPath.set(nNode, { pred: currN, edgeCount: prNode.edgeCount + 1, pathWeight: prNode.pathWeight + nEdge.weight }); bQueue.push(nNode); }); } this.addComponent(bNodes); return bPath; } /** * check if a path exists between two nodes * @param {Node} initNode the initial node * @param {Node} termNode the terminal node * @return {Boolean} a path exists between the two nodes */ hasPath(initNode, termNode) { return this.bfs(initNode).has(termNode); } /** * performs dijkstras algorithm for shortest paths to all nodes reachabe from initNode * @param {Node} initNode the initial node * @param {Node} termNode the terminal node * @return {Object} a shortest path between nodes */ dijkstra(initNode) { var reachables = this.bfs(initNode); var inspectionQueue = new NodeArray(initNode); var solutionSet = new Map().set(initNode, { pred: null, edgeCount: 0, pathWeight: 0 }); while (inspectionQueue.length &gt; 0) { var currN = inspectionQueue.shift(); var currEdges = this.edgesWithNode(currN); currEdges.forEach((tempEdge) =&gt; { let nNode = tempEdge.getNeighbor(currN); var rNodeEntry = reachables.get(nNode); var currWeight = rNodeEntry.pathWeight; var sPred = solutionSet.get(currN); var dijkstraWeight = sPred.pathWeight + tempEdge.weight; let dMap = { pred: currN, edgeCount: sPred.edgeCount + 1, pathWeight: dijkstraWeight }; let sMap = (dijkstraWeight &lt; currWeight) ? dMap : rNodeEntry; if (!solutionSet.has(nNode)) { inspectionQueue.push(nNode); solutionSet.set(nNode, sMap); } }); } return solutionSet; } /** * composes the shortest path between two nodes by backtracing dijkstra's pred attirbute * @param {Node} initNode [description] * @param {Node} termNode [description] * @return {Map} path of nodes */ shortestPath(initNode, termNode) { if (!this.hasPath(initNode, termNode)) { return false; } else { let dijkMap = this.dijkstra(initNode); let currN = termNode; let currEntry = dijkMap.get(currN); let predN = currEntry.pred; let path = new Map(); while (currN != initNode) { path.set(currN, currEntry); currN = predN; currEntry = dijkMap.get(currN); predN = currEntry.pred; } return path; } } }; module.exports = Graph; /** * [A Graph]{@link module:graphTheory.Graph} * @typedef {module:graphTheory.Graph} Graph */ × Search results Close "},"graphTheory.js.html":{"id":"graphTheory.js.html","title":"Source: graphTheory.js","body":" DocStrap Modules graphTheory Classes graphTheory.EdgegraphTheory.EdgeArraygraphTheory.GraphgraphTheory.NodegraphTheory.NodeArray Global Global Source: graphTheory.js /** * @module graphTheory */ exports.Node = require('./graphTheory/node'); exports.NodeArray = require('./graphTheory/nodeArray'); exports.DirectedEdge = require('./graphTheory/directedEdge'); exports.Edge = require('./graphTheory/edge'); exports.EdgeArray = require('./graphTheory/edgeArray'); exports.Graph = require('./graphTheory/graph'); × Search results Close "},"graphTheory_node.js.html":{"id":"graphTheory_node.js.html","title":"Source: graphTheory/node.js","body":" DocStrap Modules graphTheory Classes graphTheory.EdgegraphTheory.EdgeArraygraphTheory.GraphgraphTheory.NodegraphTheory.NodeArray Global Global Source: graphTheory/node.js /** * represent a Node * @exports Node * @constructor * @memberOf module:graphTheory * @param {String} [label = 'default'] [label property]{@link module:graphTheory.Node#label} * @param {Object} data the nodes data */ class Node { constructor(label, data) { /** * the node identifier * @type {String} */ this.label = label; this.setLabel(); /** * the node data * @type {Object} */ this.data = data; } setLabel() { return this.label = this.label || (Math.floor(Math.random() * (33) + 33)); } /** * Checks for identity via label attribute * @param {Node} newNode the node to be compared * @return {Boolean} */ isEquivalent(newNode) { return this.label === newNode.label; } } module.exports = Node; /** * [A Node]{@link module:graphTheory.Node} * @typedef {module:graphTheory.Node} Node */ × Search results Close "},"graphTheory_nodeArray.js.html":{"id":"graphTheory_nodeArray.js.html","title":"Source: graphTheory/nodeArray.js","body":" DocStrap Modules graphTheory Classes graphTheory.EdgegraphTheory.EdgeArraygraphTheory.GraphgraphTheory.NodegraphTheory.NodeArray Global Global Source: graphTheory/nodeArray.js var Node = require('./node'); /** * represents a set of Nodes * @exports NodeArray * @constructor * @memberOf! module:graphTheory */ class NodeArray extends Array { /** * checks for presence of node in this set * @param {Node} argNode [description] * @return {Boolean} */ contains(argNode) { return this.some(el =&gt; el.isEquivalent(argNode)); } /** * checks type of argument for Node status * @param {Node} argNode * @return {Boolean} */ isNode(argNode) { return argNode instanceof Node; } /** * adds a node to this set * @param {Node} argNode * @return {Boolean} */ push(argNode) { if ((this.isNode(argNode) &amp;&amp; !(this.contains(argNode)))) { super.push(argNode); } return this; } /** * returns an array shared nodes between two sets * @param {NodeArray} altArray the array to check * @return {NodeArray} the shared nodes */ intersection(altArray) { return this.filter(currNode =&gt; altArray.contains(currNode) === true); } /** * checks for presence of shared nodes between two sets * @param {NodeArray} altArray the array to check * @return {Boolean} */ intersects(altArray) { return this.some(currNode =&gt; altArray.contains(currNode) === true); } /** * returns an array nodes in this array not included in the alternate array * @param {NodeArray} altArray the array to check * @return {NodeArray} the unshared nodes */ difference(altArray) { return this.filter(n =&gt; !altArray.contains(n)); } /** * checks for presence of unshared nodes between two sets * @param {NodeArray} altArray the array to check * @return {Boolean} */ hasDistinctNodes(altArray) { return this.some(myNode =&gt; !altArray.contains(myNode)); // return altArray.some(altNode =&gt; !this.contains(altNode)); } hasSameSize(altArray) { return this.length === altArray.length; } isSubset(altArray) { return this.every(myNode =&gt; altArray.contains(myNode)); } isEquivalent(altArray) { return (this.hasSameSize(altArray) &amp;&amp; this.isSubset(altArray)); } /** * returns a combined array of nodes belonging to this and the alternate arrays * @param {NodeArray} altArray the array to combine * @return {NodeArray} the nodes */ union(altArray) { let uArray = new NodeArray(); this.forEach(currNode =&gt; uArray.push(currNode)); altArray.forEach(altNode =&gt; uArray.push(altNode)); return uArray; } /** * combines all the nodes into this nodeArray * @param {NodeArray} altArray the array to check */ unionize(altArray) { altArray.difference(this).forEach(dNode =&gt; this.push(dNode)); return this; } /** * forces return type to a NodeArray * @param {...[type]} args the arguments * @return {[NodeArray]} */ filter(...args) { return NodeArray.from(super.filter(...args)); } /** * forces return type to a NodeArray * @param {...[type]} args the arguments * @return {[NodeArray]} */ slice(...args) { return NodeArray.from(super.slice(...args)); } /** * forces return type to a NodeArray * @param {...[type]} args the arguments * @return {[NodeArray]} */ concat(...args) { return NodeArray.from(super.concat(...args)); } /** * forces return type to a NodeArray * @param {...[type]} args the arguments * @return {[NodeArray]} */ splice(...args) { return NodeArray.from(super.splice(...args)); } removeNode(nArg) { let nPos = this.indexOf(nArg); return (nPos &gt; -1) ? this.splice(nPos, 1) : false; } nodeComplement(nArg) { return this.filter(n =&gt; n.isEquivalent(nArg)); } clear() { this.splice(0); return this; } copy() { return this.slice(0); } } module.exports = NodeArray; /** * [A NodeArray]{@link module:graphTheory.NodeArray} * @typedef {module:graphTheory.NodeArray} NodeArray */ × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" DocStrap Modules graphTheory Classes graphTheory.EdgegraphTheory.EdgeArraygraphTheory.GraphgraphTheory.NodegraphTheory.NodeArray Global Global Global Type Definitions Edge An Edge Type: module:graphTheory.Edge Source: graphTheory/edge.js, line 77 EdgeArray An EdgeArray Type: module:graphTheory.EdgeArray Source: graphTheory/edgeArray.js, line 169 Graph A Graph Type: module:graphTheory.Graph Source: graphTheory/graph.js, line 333 Node A Node Type: module:graphTheory.Node Source: graphTheory/node.js, line 39 NodeArray A NodeArray Type: module:graphTheory.NodeArray Source: graphTheory/nodeArray.js, line 148 × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" DocStrap Modules graphTheory Classes graphTheory.EdgegraphTheory.EdgeArraygraphTheory.GraphgraphTheory.NodegraphTheory.NodeArray Global Global Modules Classes Edge EdgeArray Graph Node NodeArray × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" DocStrap Modules graphTheory Classes graphTheory.EdgegraphTheory.EdgeArraygraphTheory.GraphgraphTheory.NodegraphTheory.NodeArray Global Global Classes Classes Edge EdgeArray Graph Node NodeArray × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" DocStrap Modules graphTheory Classes graphTheory.EdgegraphTheory.EdgeArraygraphTheory.GraphgraphTheory.NodegraphTheory.NodeArray Global Global × Search results Close "},"module-graphTheory.html":{"id":"module-graphTheory.html","title":"Module: graphTheory","body":" DocStrap Modules graphTheory Classes graphTheory.EdgegraphTheory.EdgeArraygraphTheory.GraphgraphTheory.NodegraphTheory.NodeArray Global Global Module: graphTheory Source: graphTheory.js, line 1 Classes Edge EdgeArray Graph Node NodeArray × Search results Close "},"module-graphTheory.Edge.html":{"id":"module-graphTheory.Edge.html","title":"Class: Edge","body":" DocStrap Modules graphTheory Classes graphTheory.EdgegraphTheory.EdgeArraygraphTheory.GraphgraphTheory.NodegraphTheory.NodeArray Global Global Class: Edge graphTheory. Edge represents a connection between nodes new Edge() Source: graphTheory/edge.js, line 10 Methods containsNode(nodeArg) Checks for presence fo a node in this edge Parameters: Name Type Description nodeArg Node Source: graphTheory/edge.js, line 61 Returns: Type Node getNeighbor(nodeArg) returns the neighboring node Parameters: Name Type Description nodeArg Node Source: graphTheory/edge.js, line 69 Returns: the neighbor Type Node hasSameName(edgeArg) checks the equivalence (by label)of this edge against another Parameters: Name Type Description edgeArg Edge edge to be checked Source: graphTheory/edge.js, line 45 Returns: Type Boolean hasSameNodes(edgeArg) checks the equivalence of this edges nodes against another Parameters: Name Type Description edgeArg Edge edge to be checked Source: graphTheory/edge.js, line 53 Returns: Type Boolean isEquivalent(edgeArg) checks the equivalence (by label)of this edge against another Parameters: Name Type Description edgeArg Edge edge to be checked Source: graphTheory/edge.js, line 36 Returns: Type Boolean × Search results Close "},"module-graphTheory.EdgeArray.html":{"id":"module-graphTheory.EdgeArray.html","title":"Class: EdgeArray","body":" DocStrap Modules graphTheory Classes graphTheory.EdgegraphTheory.EdgeArraygraphTheory.GraphgraphTheory.NodegraphTheory.NodeArray Global Global Class: EdgeArray graphTheory. EdgeArray represents a set of Edges new EdgeArray() Source: graphTheory/edgeArray.js, line 11 Methods concat(args) forces return type to a EdgeArray Parameters: Name Type Description args Source: graphTheory/edgeArray.js, line 136 Returns: contains(argEdge) checks for presence of edge in this set Parameters: Name Type Description argEdge Edge [description] Source: graphTheory/edgeArray.js, line 17 Returns: Type Boolean difference(altArray) returns an array edges in this array not included in the alternate array Parameters: Name Type Description altArray EdgeArray the array to check Source: graphTheory/edgeArray.js, line 75 Returns: the unshared edges Type EdgeArray filter(args) forces return type to a NodeArray Parameters: Name Type Description args Source: graphTheory/edgeArray.js, line 120 Returns: getNodes() assembles each edges nodes into one large array Source: graphTheory/edgeArray.js, line 43 Returns: Type NodeArray hasDistinctEdges(altArray) checks for presence of unshared edges between two sets Parameters: Name Type Description altArray EdgeArray the array to check Source: graphTheory/edgeArray.js, line 83 Returns: Type Boolean intersection(altArray) returns an array shared edges between two sets Parameters: Name Type Description altArray EdgeArray the array to check Source: graphTheory/edgeArray.js, line 58 Returns: the shared edges Type EdgeArray intersects(altArray) checks for presence of shared edges between two sets Parameters: Name Type Description altArray EdgeArray the array to check Source: graphTheory/edgeArray.js, line 67 Returns: Type Boolean isEdge(argEdge) checks type of argument for Edge status Parameters: Name Type Description argEdge Edge Source: graphTheory/edgeArray.js, line 25 Returns: Type Boolean push(argEdge) adds a edge to this set Parameters: Name Type Description argEdge Edge Source: graphTheory/edgeArray.js, line 33 Returns: Type Boolean slice(args) forces return type to a EdgeArray Parameters: Name Type Description args Source: graphTheory/edgeArray.js, line 128 Returns: splice(args) forces return type to a EdgeArray Parameters: Name Type Description args Source: graphTheory/edgeArray.js, line 144 Returns: union(altArray) returns a combined array of edges belonging to this and the alternate arrays Parameters: Name Type Description altArray EdgeArray the array to combine Source: graphTheory/edgeArray.js, line 100 Returns: the edges Type EdgeArray unionize(altArray) combines all the edges into this edgeArray Parameters: Name Type Description altArray EdgeArray the array to check Source: graphTheory/edgeArray.js, line 111 × Search results Close "},"module-graphTheory.Graph.html":{"id":"module-graphTheory.Graph.html","title":"Class: Graph","body":" DocStrap Modules graphTheory Classes graphTheory.EdgegraphTheory.EdgeArraygraphTheory.GraphgraphTheory.NodegraphTheory.NodeArray Global Global Class: Graph graphTheory. Graph represents a Graph new Graph() Source: graphTheory/graph.js, line 12 Methods addComponent(compArg) adds a component to the graph if not present Parameters: Name Type Description compArg Component [description] Source: graphTheory/graph.js, line 187 addNode(node) adds a node to the nodes array, if not already contained Parameters: Name Type Description node Node the new node Source: graphTheory/graph.js, line 34 bfs(initNode) breadth first search, recursively adds all immediate neighbors, to a component of nodes reachabe by a initial node Parameters: Name Type Description initNode Node inital node Source: graphTheory/graph.js, line 234 Returns: a key-value store of nodes and edge distances Type Map createEdge(sNode, dNode, weight) creates a new edge given two nodes Parameters: Name Type Description sNode Node source node dNode Node destination node weight Number weight of new edge Source: graphTheory/graph.js, line 69 dfs(initNode) depth first search, initializes a new component of reachable nodes, and constructs a path to each of those node from the source Parameters: Name Type Description initNode Node inital node Source: graphTheory/graph.js, line 168 Returns: a key-value store of nodes and edge distances Type Component dijkstra(initNode, termNode) performs dijkstras algorithm for shortest paths to all nodes reachabe from initNode Parameters: Name Type Description initNode Node the initial node termNode Node the terminal node Source: graphTheory/graph.js, line 276 Returns: a shortest path between nodes Type Object edgesWithNode(nodeArg) Parameters: Name Type Description nodeArg Node source node Source: graphTheory/graph.js, line 60 Returns: the edges connected to source Type Array.&lt;Edge&gt; findIntersectingComponent(compArg) returns any current components which intersect with the specified component Parameters: Name Type Description compArg Component the component to be checked Source: graphTheory/graph.js, line 199 Returns: the first intersecting component Type Component getNeighbors(nodeArg) Parameters: Name Type Description nodeArg Node the source node Source: graphTheory/graph.js, line 111 Returns: the neighboring nodes Type Array.&lt;Node&gt; getUnvisitedEdges(nodeArg, compArg) returns all of the nodes Edges which contain nodes not yet in the specified component Parameters: Name Type Description nodeArg Node [description] compArg Component [description] Source: graphTheory/graph.js, line 123 Returns: [description] Type EdgeArray getUnvisitedNeighbors(nodeArg, compArg) returns all of the nodes neighbors not yet part od the component Parameters: Name Type Description nodeArg Node [description] compArg Component [description] Source: graphTheory/graph.js, line 133 Returns: [description] Type NodeArray hasIntersectingComponent(compArg) checks if any current components share nodes with the argument Parameters: Name Type Description compArg Component [description] Source: graphTheory/graph.js, line 225 Returns: [description] Type Boolean hasPath(initNode, termNode) check if a path exists between two nodes Parameters: Name Type Description initNode Node the initial node termNode Node the terminal node Source: graphTheory/graph.js, line 267 Returns: a path exists between the two nodes Type Boolean integrateComponent(compArg) integrates a component into any of the graphs intersectung components Parameters: Name Type Description compArg Component [description] Source: graphTheory/graph.js, line 216 mergeComponents(origComp, newComp) combines the nodes of two intersecting components Parameters: Name Type Description origComp Component newComp Component Source: graphTheory/graph.js, line 207 shortestPath(initNode, termNode) composes the shortest path between two nodes by backtracing dijkstra's pred attirbute Parameters: Name Type Description initNode Node [description] termNode Node [description] Source: graphTheory/graph.js, line 313 Returns: path of nodes Type Map visitPath(pathArg, compArg) adds all unvisited nodes in the path to the specified component adds each node connected to an edge to a (depth) path Parameters: Name Type Description pathArg Map the path to be explored compArg Component a key value store of node's and distances Source: graphTheory/graph.js, line 142 × Search results Close "},"module-graphTheory.Node.html":{"id":"module-graphTheory.Node.html","title":"Class: Node","body":" DocStrap Modules graphTheory Classes graphTheory.EdgegraphTheory.EdgeArraygraphTheory.GraphgraphTheory.NodegraphTheory.NodeArray Global Global Class: Node graphTheory. Node represent a Node new Node( [label], data) Parameters: Name Type Argument Default Description label String &lt;optional&gt; 'default' label property data Object the nodes data Source: graphTheory/node.js, line 9 Methods isEquivalent(newNode) Checks for identity via label attribute Parameters: Name Type Description newNode Node the node to be compared Source: graphTheory/node.js, line 33 Returns: Type Boolean × Search results Close "},"module-graphTheory.NodeArray.html":{"id":"module-graphTheory.NodeArray.html","title":"Class: NodeArray","body":" DocStrap Modules graphTheory Classes graphTheory.EdgegraphTheory.EdgeArraygraphTheory.GraphgraphTheory.NodegraphTheory.NodeArray Global Global Class: NodeArray graphTheory. NodeArray represents a set of Nodes new NodeArray() Source: graphTheory/nodeArray.js, line 8 Methods concat(args) forces return type to a NodeArray Parameters: Name Type Description args Source: graphTheory/nodeArray.js, line 118 Returns: contains(argNode) checks for presence of node in this set Parameters: Name Type Description argNode Node [description] Source: graphTheory/nodeArray.js, line 14 Returns: Type Boolean difference(altArray) returns an array nodes in this array not included in the alternate array Parameters: Name Type Description altArray NodeArray the array to check Source: graphTheory/nodeArray.js, line 57 Returns: the unshared nodes Type NodeArray filter(args) forces return type to a NodeArray Parameters: Name Type Description args Source: graphTheory/nodeArray.js, line 102 Returns: hasDistinctNodes(altArray) checks for presence of unshared nodes between two sets Parameters: Name Type Description altArray NodeArray the array to check Source: graphTheory/nodeArray.js, line 65 Returns: Type Boolean intersection(altArray) returns an array shared nodes between two sets Parameters: Name Type Description altArray NodeArray the array to check Source: graphTheory/nodeArray.js, line 41 Returns: the shared nodes Type NodeArray intersects(altArray) checks for presence of shared nodes between two sets Parameters: Name Type Description altArray NodeArray the array to check Source: graphTheory/nodeArray.js, line 49 Returns: Type Boolean isNode(argNode) checks type of argument for Node status Parameters: Name Type Description argNode Node Source: graphTheory/nodeArray.js, line 22 Returns: Type Boolean push(argNode) adds a node to this set Parameters: Name Type Description argNode Node Source: graphTheory/nodeArray.js, line 30 Returns: Type Boolean slice(args) forces return type to a NodeArray Parameters: Name Type Description args Source: graphTheory/nodeArray.js, line 110 Returns: splice(args) forces return type to a NodeArray Parameters: Name Type Description args Source: graphTheory/nodeArray.js, line 126 Returns: union(altArray) returns a combined array of nodes belonging to this and the alternate arrays Parameters: Name Type Description altArray NodeArray the array to combine Source: graphTheory/nodeArray.js, line 83 Returns: the nodes Type NodeArray unionize(altArray) combines all the nodes into this nodeArray Parameters: Name Type Description altArray NodeArray the array to check Source: graphTheory/nodeArray.js, line 93 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
