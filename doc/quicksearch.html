<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"graph.js.html":{"id":"graph.js.html","title":"Source: graph.js","body":" DocStrap Classes graphTheory.Graph Global Global Source: graph.js var Node = require('./node'); var NodeArray = require('./nodeArray'); var Edge = require('./edge'); var EdgeArray = require('./edgeArray'); var Component = require('./component'); var EdgeComponent = require('./edgeComponent'); /** * represents a Graph * @exports Graph * @constructor * @memberOf! module:graphTheory */ class Graph { constructor() { /** * the graph's nodes * @type {NodeArray} */ this.nodes = new NodeArray(); /** * the graph's edges * @type {EdgeArray} */ this.edges = new EdgeArray(); /** * the graph's components * @type {Component[]} */ this.components = []; } /** * adds a node to the nodes array, if not already contained * @param {Node} node the new node */ addNode(node) { this.nodes.push(node); } /** * creates a new edge given two nodes * @param {Node} sNode source node * @param {Node} dNode destination node * @param {Number} weight weight of new edge */ addEdge(sNode, dNode, weight) { var tempEdge = new Edge(sNode, dNode, weight); this.edges.push(tempEdge); } /** * @param {Node} nodeArg source node * @return {Edge[]} the edges connected to source */ getEdges(nodeArg) { return this.edges.filter(tempEdge =&gt; tempEdge.containsNode(nodeArg) === true); } /** * * @param {Node} nodeArg the source node * @return {Node[]} the neighboring nodes */ getNeighbors(nodeArg) { return this.getEdges(nodeArg).map(tempEdge =&gt; tempEdge.getNeighbor(nodeArg)); } /** * adds all unvisited nodes in the path to the specified component * adds each node connected to an edge to a (depth) path * @param {Map} pathArg the path to be explored * @param {Component} compArg a key value store of node's and distances */ visitComponent(pathArg, compArg) { let nodeArg = [...pathArg.keys()].pop(); let nextEdges = this.getUnvisitedEdges(nodeArg, compArg); if (nextEdges.length === 0) { return pathArg; } else { let predWeight = pathArg.get(nodeArg).pathWeight; let predCount = pathArg.get(nodeArg).edgeCount; nextEdges.forEach(currEdge =&gt; { let nabe = currEdge.getNeighbor(nodeArg); compArg.addEdge(currEdge); pathArg.set(nabe, { pred: nodeArg, edgeCount: predCount + 1, pathWeight: predWeight + currEdge.weight }); this.visitComponent(pathArg, compArg); }); } } /** * depth first search, initializes a new component of reachable nodes, and constructs a path to each of those node from the source * @param {Node} initNode inital node * @return {Component} a key-value store of nodes and edge distances */ depthTraverse(initNode) { let currComponent = new EdgeComponent(); let path = new Map(); path.set(initNode, { pred: null, edgeCount: 0, pathWeight: 0 }); this.visitComponent(path, currComponent); this.addComponent(currComponent); return path; } /** * adds a component to the graph if not present * @param {Component} compArg [description] */ addComponent(compArg) { this.hasIntersectingComponent(compArg) ? this.integrateComponent(compArg) : this.components.push(compArg); } /** * returns any current components which intersect with the specified component * @param {Component} compArg the component to be checked * @return {Component} the first intersecting component */ findIntersectingComponent(compArg) { return this.components.find(currComp =&gt; currComp.intersects(compArg) === true); } /** * combines the nodes of two intersecting components * @param {Component} origComp * @param {Component} newComp */ mergeComponents(origComp, newComp) { origComp.unionize(newComp); } /** * integrates a component into any of the graphs intersectung components * @param {Component} compArg [description] */ integrateComponent(compArg) { let oComp = this.findIntersectingComponent(compArg); this.mergeComponents(oComp, compArg); } /** * checks if any current components share nodes with the argument * @param {Component} compArg [description] * @return {Boolean} [description] */ hasIntersectingComponent(compArg) { return this.components.some(currComp =&gt; currComp.intersects(compArg)); } /** * returns all of the nodes Edges which contain nodes not yet in the specified component * @param {Node} nodeArg [description] * @param {Component} compArg [description] * @return {EdgeArray} [description] */ getUnvisitedEdges(nodeArg, compArg) { return this.getEdges(nodeArg).filter(currEdge =&gt; { var nNode = currEdge.getNeighbor(nodeArg) return !compArg.containsNode(nNode); }); } /** * returns all of the nodes neighbors not yet part od the component * @param {Node} nodeArg [description] * @param {Component} compArg [description] * @return {NodeArray} [description] */ getUnvisitedNeighbors(nodeArg, compArg) { return this.getNeighbors(nodeArg).filter(currNodeEntry =&gt; !(compArg.containsNode(currNodeEntry))); } /** * breadth first search, recursively adds all immediate neighbors, to a component of nodes reachabe by a initial node * @param {Node} initNode inital node * @return {Map} a key-value store of nodes and edge distances */ bfs(initNode) { var bComp = new EdgeComponent(); var bPath = new Map(); bPath.set(initNode, { pred: null, pathWeight: 0, edgeCount: 0 }); var level = 1; var bQueue = new NodeArray(); bQueue.push(initNode); while (bQueue.length &gt; 0) { var currN = bQueue.shift(); var currEdges = this.getUnvisitedEdges(currN, bComp); var frontier = new NodeArray(); let predWeight = bPath.get(currN).pathWeight; let predCount = bPath.get(currN).edgeCount; currEdges.forEach((nEdge) =&gt; { let nNode = nEdge.getNeighbor(currN); bPath.set(nNode, { pred: currN, edgeCount: level, pathWeight: predWeight + nEdge.weight }); bComp.addEdge(nEdge); frontier.push(nNode); }); bQueue = frontier; level++; } this.addComponent(bComp); return bPath; } /** * check if a path exists between two nodes * @param {Node} initNode the initial node * @param {Node} termNode the terminal node * @return {Boolean} a path exists between the two nodes */ hasPath(initNode, termNode) { var bPath = this.bfs(initNode); return bPath.has(termNode); } /** * performs dijkstras algorithm for shortest paths to all nodes reachabe from initNode * @param {Node} initNode the initial node * @param {Node} termNode the terminal node * @return {Object} a shortest path between nodes */ dijkstra(initNode) { var reachables = this.bfs(initNode); var inspectionQueue = new NodeArray(initNode); var solutionSet = new Map(); solutionSet.set(initNode, { pred: null, edgeCount: 0, pathWeight: 0 }); while (inspectionQueue.length &gt; 0) { var currN = inspectionQueue.shift(); var currEdges = this.getEdges(currN); currEdges.forEach((tempEdge) =&gt; { let nNode = tempEdge.getNeighbor(currN); var rNodeEntry = reachables.get(nNode); var currWeight = rNodeEntry.pathWeight; var sPred = solutionSet.get(currN); var dijkstraWeight = sPred.pathWeight + tempEdge.weight; var dMap = { pred: currN, edgeCount: sPred.edgeCount + 1, pathWeight: dijkstraWeight }; var sMap = (dijkstraWeight &lt; currWeight) ? dMap : rNodeEntry; if (!solutionSet.has(nNode)) { inspectionQueue.push(nNode); solutionSet.set(nNode, sMap); } }); } return solutionSet; } /** * composes the shortest path between two nodes by backtracing dijkstra's pred attirbute * @param {Node} initNode [description] * @param {Node} termNode [description] * @return {Map} path of nodes */ shortestPath(initNode, termNode) { if (!this.hasPath(initNode, termNode)) { return false; } else { let dijkMap = this.dijkstra(initNode); let currN = termNode; let currEntry = dijkMap.get(currN); let predN = currEntry.pred; let path = new Map(); while (currN != initNode) { path.set(currN, currEntry); currN = predN; currEntry = dijkMap.get(currN); predN = currEntry.pred; } return path; } } }; module.exports = Graph; /** * [A Graph]{@link module:graphTheory.Graph} * @typedef {module:graphTheory.Graph} Graph */ × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" DocStrap Classes graphTheory.Graph Global Global Global Type Definitions Graph A Graph Type: module:graphTheory.Graph Source: graph.js, line 286 × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" DocStrap Classes graphTheory.Graph Global Global Classes Classes Graph × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" DocStrap Classes graphTheory.Graph Global Global × Search results Close "},"module-graphTheory.Graph.html":{"id":"module-graphTheory.Graph.html","title":"Class: Graph","body":" DocStrap Classes graphTheory.Graph Global Global Class: Graph Graph represents a Graph new Graph() Source: graph.js, line 14 Methods addComponent(compArg) adds a component to the graph if not present Parameters: Name Type Description compArg Component [description] Source: graph.js, line 111 addEdge(sNode, dNode, weight) creates a new edge given two nodes Parameters: Name Type Description sNode Node source node dNode Node destination node weight Number weight of new edge Source: graph.js, line 45 addNode(node) adds a node to the nodes array, if not already contained Parameters: Name Type Description node Node the new node Source: graph.js, line 36 bfs(initNode) breadth first search, recursively adds all immediate neighbors, to a component of nodes reachabe by a initial node Parameters: Name Type Description initNode Node inital node Source: graph.js, line 175 Returns: a key-value store of nodes and edge distances Type Map depthTraverse(initNode) depth first search, initializes a new component of reachable nodes, and constructs a path to each of those node from the source Parameters: Name Type Description initNode Node inital node Source: graph.js, line 95 Returns: a key-value store of nodes and edge distances Type Component dijkstra(initNode, termNode) performs dijkstras algorithm for shortest paths to all nodes reachabe from initNode Parameters: Name Type Description initNode Node the initial node termNode Node the terminal node Source: graph.js, line 224 Returns: a shortest path between nodes Type Object findIntersectingComponent(compArg) returns any current components which intersect with the specified component Parameters: Name Type Description compArg Component the component to be checked Source: graph.js, line 119 Returns: the first intersecting component Type Component getEdges(nodeArg) Parameters: Name Type Description nodeArg Node source node Source: graph.js, line 53 Returns: the edges connected to source Type Array.&lt;Edge&gt; getNeighbors(nodeArg) Parameters: Name Type Description nodeArg Node the source node Source: graph.js, line 61 Returns: the neighboring nodes Type Array.&lt;Node&gt; getUnvisitedEdges(nodeArg, compArg) returns all of the nodes Edges which contain nodes not yet in the specified component Parameters: Name Type Description nodeArg Node [description] compArg Component [description] Source: graph.js, line 153 Returns: [description] Type EdgeArray getUnvisitedNeighbors(nodeArg, compArg) returns all of the nodes neighbors not yet part od the component Parameters: Name Type Description nodeArg Node [description] compArg Component [description] Source: graph.js, line 165 Returns: [description] Type NodeArray hasIntersectingComponent(compArg) checks if any current components share nodes with the argument Parameters: Name Type Description compArg Component [description] Source: graph.js, line 144 Returns: [description] Type Boolean hasPath(initNode, termNode) check if a path exists between two nodes Parameters: Name Type Description initNode Node the initial node termNode Node the terminal node Source: graph.js, line 214 Returns: a path exists between the two nodes Type Boolean integrateComponent(compArg) integrates a component into any of the graphs intersectung components Parameters: Name Type Description compArg Component [description] Source: graph.js, line 135 mergeComponents(origComp, newComp) combines the nodes of two intersecting components Parameters: Name Type Description origComp Component newComp Component Source: graph.js, line 128 shortestPath(initNode, termNode) composes the shortest path between two nodes by backtracing dijkstra's pred attirbute Parameters: Name Type Description initNode Node [description] termNode Node [description] Source: graph.js, line 263 Returns: path of nodes Type Map visitComponent(pathArg, compArg) adds all unvisited nodes in the path to the specified component adds each node connected to an edge to a (depth) path Parameters: Name Type Description pathArg Map the path to be explored compArg Component a key value store of node's and distances Source: graph.js, line 70 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
