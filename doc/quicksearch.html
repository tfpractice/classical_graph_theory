<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"graphTheory_edge.js.html":{"id":"graphTheory_edge.js.html","title":"Source: graphTheory/edge.js","body":" DocStrap Modules graphTheory Classes graphTheory.EdgegraphTheory.EdgeArraygraphTheory.EdgeComponentgraphTheory.GraphgraphTheory.NodegraphTheory.NodeArraygraphTheory.Vertex Global Global Source: graphTheory/edge.js var Node = require('./node'); var NodeArray = require('./nodeArray'); /** * represents a connection between nodes * @exports Edge * @constructor * @memberOf! module:graphTheory */ class Edge { constructor(n1 = new Node(), n2 = new Node(), weight = 0) { /** * an array of nodes * @type {NodeArray} */ this.nodes = NodeArray.of(n1, n2); /** * the weight of the edge * @type {Number} */ this.weight = weight; /** * an identifier for the Edge * @type {String} */ this.label = `${n1.label}_${n2.label}`; } /** * checks the equivalence (by label)of this edge against another * @param {Edge} edgeArg edge to be checked * @return {Boolean} */ isEquivalent(edgeArg) { return (this.label) ? this.label === edgeArg.label : false; } /** * Checks for presence fo a node in this edge * @param {Node} nodeArg * @return {Node} */ containsNode(nodeArg) { return this.nodes.contains(nodeArg); } /** * returns the neighboring node * @param {Node} nodeArg * @return {Node} the neighbor */ getNeighbor(nodeArg) { return this.nodes.find(currNode =&gt; currNode != nodeArg); } } module.exports = Edge; /** * [An Edge]{@link module:graphTheory.Edge} * @typedef {module:graphTheory.Edge} Edge */ × Search results Close "},"graphTheory_edgeArray.js.html":{"id":"graphTheory_edgeArray.js.html","title":"Source: graphTheory/edgeArray.js","body":" DocStrap Modules graphTheory Classes graphTheory.EdgegraphTheory.EdgeArraygraphTheory.EdgeComponentgraphTheory.GraphgraphTheory.NodegraphTheory.NodeArraygraphTheory.Vertex Global Global Source: graphTheory/edgeArray.js var Node = require('./node'); var NodeArray = require('./nodeArray'); var Edge = require('./edge'); var DirectedEdge = require('./directedEdge'); /** * represents a set of Edges * @exports EdgeArray * @constructor * @memberOf! module:graphTheory */ class EdgeArray extends Array { /** * checks for presence of edge in this set * @param {Edge} argEdge [description] * @return {Boolean} */ contains(argEdge) { return this.some(el =&gt; (el.isEquivalent(argEdge) === true)); } /** * checks type of argument for Edge status * @param {Edge} argEdge * @return {Boolean} */ isEdge(argEdge) { return argEdge instanceof Edge; } /** * adds a edge to this set * @param {Edge} argEdge * @return {Boolean} */ push(argEdge) { return (this.isEdge(argEdge) &amp;&amp; !(this.contains(argEdge))) ? super.push(argEdge) : false; } /** * assembles each edges nodes into one large array * @return {NodeArray} */ getNodes() { return this.reduce((nArray, e) =&gt; { nArray.unionize(e.nodes); return nArray; }, new NodeArray()); } /** * returns an array shared edges between two sets * @param {EdgeArray} altArray the array to check * @return {EdgeArray} the shared edges */ intersection(altArray) { return this.filter(currEdge =&gt; altArray.contains(currEdge) === true); } /** * checks for presence of shared edges between two sets * @param {EdgeArray} altArray the array to check * @return {Boolean} */ intersects(altArray) { return this.some(currEdge =&gt; altArray.contains(currEdge) === true); } /** * returns an array edges in this array not included in the alternate array * @param {EdgeArray} altArray the array to check * @return {EdgeArray} the unshared edges */ difference(altArray) { let diffArray = new EdgeArray(); this.reduce((dArray, currEdge) =&gt; { if (!altArray.contains(currEdge)) dArray.push(currEdge); return dArray; }, diffArray); altArray.reduce((dArray, altEdge) =&gt; { if (!this.contains(altEdge)) dArray.push(altEdge); return dArray; }, diffArray); return diffArray; } /** * checks for presence of unshared edges between two sets * @param {EdgeArray} altArray the array to check * @return {Boolean} */ hasDistinctEdges(altArray) { return altArray.some(altEdge =&gt; !this.contains(altEdge)); } /** * returns a combined array of edges belonging to this and the alternate arrays * @param {EdgeArray} altArray the array to combine * @return {EdgeArray} the edges */ union(altArray) { let uArray = new EdgeArray(); this.forEach(currEdge =&gt; uArray.push(currEdge)); altArray.forEach(altEdge =&gt; uArray.push(altEdge)); return uArray; } /** * combines all the edges into this edgeArray * @param {EdgeArray} altArray the array to check */ unionize(altArray) { this.difference(altArray).forEach(dEdge =&gt; this.push(dEdge)); } } module.exports = EdgeArray; /** * [An EdgeArray]{@link module:graphTheory.EdgeArray} * @typedef {module:graphTheory.EdgeArray} EdgeArray */ × Search results Close "},"graphTheory_edgeComponent.js.html":{"id":"graphTheory_edgeComponent.js.html","title":"Source: graphTheory/edgeComponent.js","body":" DocStrap Modules graphTheory Classes graphTheory.EdgegraphTheory.EdgeArraygraphTheory.EdgeComponentgraphTheory.GraphgraphTheory.NodegraphTheory.NodeArraygraphTheory.Vertex Global Global Source: graphTheory/edgeComponent.js var Node = require('./node'); var NodeArray = require('./nodeArray'); var Edge = require('./directedEdge'); var EdgeArray = require('./edgeArray'); /** * represents a set of Connected Edges * @exports EdgeComponent * @constructor * @memberOf! module:graphTheory */ class EdgeComponent { constructor() { /** * the Egdes in this component * @type {EdgeArray} */ this.edges = new EdgeArray(); /** * The nodes in this component * @type {NodeArray} */ this.nodes = new NodeArray(); /** * the number of nodes in this components * @type {Number} */ this.arity = 0; } /** * sets the arity to the length of the nodes array */ resetArity() { this.arity = this.nodes.length; } /** * composes all of the edges nodes into one large array * @return {NodeArray} */ getNodes() { return this.edges.getNodes(); } /** * resets the nodes array based on the edges */ updateNodes() { this.nodes = this.getNodes(); this.resetArity(); } /** * checks for presence of an edge in this component * @param {Edge} edgeArg * @return {Boolean} */ containsEdge(edgeArg) { return this.edges.contains(edgeArg); } /** * checks this component for the presence of a node * @param {Node} nodeArg * @return {Boolean} */ containsNode(nodeArg) { return this.nodes.contains(nodeArg); } /** * adds an edge and its nodes to this component * @param {Edge} edgeArg [description] */ addEdge(edgeArg) { this.edges.push(edgeArg); this.updateNodes(); } /** * gets the nodes of each edge * @return {NodeArray} */ nodeMap() { return this.edges.map(currEdge =&gt; currEdge.nodes); } /** * returns an array shared edges between two sets * @param {Component} compArg the component to check * @return {EdgeArray} the shared edges */ intersects(compArg) { return this.edges.intersects(compArg.edges); } /** * returns an array shared nodes between two components * @param {Component} compArg the component to check * @return {EdgeArray} the shared edges */ intersection(compArg) { return this.nodes.intersection(compArg.nodes); } /** * returns an array nodes in this array not included in the alternate array * @param {Component} compArg the component to check * @return {NodeArray} the unshared nodes */ difference(compArg) { return this.nodes.difference(compArg.nodes); } /** * returns a combined array of edges belonging to this and the alternate arrays * @param {Component} compArg the component to check * @return {EdgeArray} the edges */ union(compArg) { return this.edges.union(compArg.edges); } /** * combines all the edges into this Component * @param {Component} compArg the component to check */ unionize(compArg) { this.edges.unionize(compArg.edges); this.updateNodes(); } } module.exports = EdgeComponent; /** * [An EdgeComponent]{@link module:graphTheory.EdgeComponent} * @typedef {module:graphTheory.EdgeComponent} EdgeComponent */ × Search results Close "},"graphTheory_graph.js.html":{"id":"graphTheory_graph.js.html","title":"Source: graphTheory/graph.js","body":" DocStrap Modules graphTheory Classes graphTheory.EdgegraphTheory.EdgeArraygraphTheory.EdgeComponentgraphTheory.GraphgraphTheory.NodegraphTheory.NodeArraygraphTheory.Vertex Global Global Source: graphTheory/graph.js var Node = require('./node'); var NodeArray = require('./nodeArray'); var Edge = require('./edge'); var EdgeArray = require('./edgeArray'); var Component = require('./component'); var EdgeComponent = require('./edgeComponent'); /** * represents a Graph * @exports Graph * @constructor * @memberOf! module:graphTheory */ class Graph { constructor() { /** * the graph's nodes * @type {NodeArray} */ this.nodes = new NodeArray(); /** * the graph's edges * @type {EdgeArray} */ this.edges = new EdgeArray(); /** * the graph's components * @type {Component[]} */ this.components = []; } /** * adds a node to the nodes array, if not already contained * @param {Node} node the new node */ addNode(node) { this.nodes.push(node); } /** * creates a new edge given two nodes * @param {Node} sNode source node * @param {Node} dNode destination node * @param {Number} weight weight of new edge */ addEdge(sNode, dNode, weight) { var tempEdge = new Edge(sNode, dNode, weight); this.edges.push(tempEdge); } /** * @param {Node} nodeArg source node * @return {Edge[]} the edges connected to source */ getEdges(nodeArg) { return this.edges.filter(tempEdge =&gt; tempEdge.containsNode(nodeArg) === true); } /** * * @param {Node} nodeArg the source node * @return {Node[]} the neighboring nodes */ getNeighbors(nodeArg) { return this.getEdges(nodeArg).map(tempEdge =&gt; tempEdge.getNeighbor(nodeArg)); } /** * adds all unvisited nodes in the path to the specified component * adds each node connected to an edge to a (depth) path * @param {Map} pathArg the path to be explored * @param {Component} compArg a key value store of node's and distances */ visitComponent(pathArg, compArg) { let nodeArg = [...pathArg.keys()].pop(); let nextEdges = this.getUnvisitedEdges(nodeArg, compArg); if (nextEdges.length === 0) { return pathArg; } else { let predWeight = pathArg.get(nodeArg).pathWeight; let predCount = pathArg.get(nodeArg).edgeCount; nextEdges.forEach(currEdge =&gt; { let nabe = currEdge.getNeighbor(nodeArg); compArg.addEdge(currEdge); pathArg.set(nabe, { pred: nodeArg, edgeCount: predCount + 1, pathWeight: predWeight + currEdge.weight }); this.visitComponent(pathArg, compArg); }); } } /** * depth first search, initializes a new component of reachable nodes, and constructs a path to each of those node from the source * @param {Node} initNode inital node * @return {Component} a key-value store of nodes and edge distances */ depthTraverse(initNode) { let currComponent = new EdgeComponent(); let path = new Map(); path.set(initNode, { pred: null, edgeCount: 0, pathWeight: 0 }); this.visitComponent(path, currComponent); this.addComponent(currComponent); return path; } /** * adds a component to the graph if not present * @param {Component} compArg [description] */ addComponent(compArg) { this.hasIntersectingComponent(compArg) ? this.integrateComponent(compArg) : this.components.push(compArg); } /** * returns any current components which intersect with the specified component * @param {Component} compArg the component to be checked * @return {Component} the first intersecting component */ findIntersectingComponent(compArg) { return this.components.find(currComp =&gt; currComp.intersects(compArg) === true); } /** * combines the nodes of two intersecting components * @param {Component} origComp * @param {Component} newComp */ mergeComponents(origComp, newComp) { origComp.unionize(newComp); } /** * integrates a component into any of the graphs intersectung components * @param {Component} compArg [description] */ integrateComponent(compArg) { let oComp = this.findIntersectingComponent(compArg); this.mergeComponents(oComp, compArg); } /** * checks if any current components share nodes with the argument * @param {Component} compArg [description] * @return {Boolean} [description] */ hasIntersectingComponent(compArg) { return this.components.some(currComp =&gt; currComp.intersects(compArg)); } /** * returns all of the nodes Edges which contain nodes not yet in the specified component * @param {Node} nodeArg [description] * @param {Component} compArg [description] * @return {EdgeArray} [description] */ getUnvisitedEdges(nodeArg, compArg) { return this.getEdges(nodeArg).filter(currEdge =&gt; { var nNode = currEdge.getNeighbor(nodeArg) return !compArg.containsNode(nNode); }); } /** * returns all of the nodes neighbors not yet part od the component * @param {Node} nodeArg [description] * @param {Component} compArg [description] * @return {NodeArray} [description] */ getUnvisitedNeighbors(nodeArg, compArg) { return this.getNeighbors(nodeArg).filter(currNodeEntry =&gt; !(compArg.containsNode(currNodeEntry))); } /** * breadth first search, recursively adds all immediate neighbors, to a component of nodes reachabe by a initial node * @param {Node} initNode inital node * @return {Map} a key-value store of nodes and edge distances */ bfs(initNode) { var bComp = new EdgeComponent(); var bPath = new Map(); bPath.set(initNode, { pred: null, pathWeight: 0, edgeCount: 0 }); var level = 1; var bQueue = new NodeArray(); bQueue.push(initNode); while (bQueue.length &gt; 0) { var currN = bQueue.shift(); var currEdges = this.getUnvisitedEdges(currN, bComp); var frontier = new NodeArray(); let predWeight = bPath.get(currN).pathWeight; let predCount = bPath.get(currN).edgeCount; currEdges.forEach((nEdge) =&gt; { let nNode = nEdge.getNeighbor(currN); bPath.set(nNode, { pred: currN, edgeCount: level, pathWeight: predWeight + nEdge.weight }); bComp.addEdge(nEdge); frontier.push(nNode); }); bQueue = frontier; level++; } this.addComponent(bComp); return bPath; } /** * check if a path exists between two nodes * @param {Node} initNode the initial node * @param {Node} termNode the terminal node * @return {Boolean} a path exists between the two nodes */ hasPath(initNode, termNode) { var bPath = this.bfs(initNode); return bPath.has(termNode); } /** * performs dijkstras algorithm for shortest paths to all nodes reachabe from initNode * @param {Node} initNode the initial node * @param {Node} termNode the terminal node * @return {Object} a shortest path between nodes */ dijkstra(initNode) { var reachables = this.bfs(initNode); var inspectionQueue = new NodeArray(initNode); var solutionSet = new Map(); solutionSet.set(initNode, { pred: null, edgeCount: 0, pathWeight: 0 }); while (inspectionQueue.length &gt; 0) { var currN = inspectionQueue.shift(); var currEdges = this.getEdges(currN); currEdges.forEach((tempEdge) =&gt; { let nNode = tempEdge.getNeighbor(currN); var rNodeEntry = reachables.get(nNode); var currWeight = rNodeEntry.pathWeight; var sPred = solutionSet.get(currN); var dijkstraWeight = sPred.pathWeight + tempEdge.weight; var dMap = { pred: currN, edgeCount: sPred.edgeCount + 1, pathWeight: dijkstraWeight }; var sMap = (dijkstraWeight &lt; currWeight) ? dMap : rNodeEntry; if (!solutionSet.has(nNode)) { inspectionQueue.push(nNode); solutionSet.set(nNode, sMap); } }); } return solutionSet; } /** * composes the shortest path between two nodes by backtracing dijkstra's pred attirbute * @param {Node} initNode [description] * @param {Node} termNode [description] * @return {Map} path of nodes */ shortestPath(initNode, termNode) { if (!this.hasPath(initNode, termNode)) { return false; } else { let dijkMap = this.dijkstra(initNode); let currN = termNode; let currEntry = dijkMap.get(currN); let predN = currEntry.pred; let path = new Map(); while (currN != initNode) { path.set(currN, currEntry); currN = predN; currEntry = dijkMap.get(currN); predN = currEntry.pred; } return path; } } }; module.exports = Graph; /** * [A Graph]{@link module:graphTheory.Graph} * @typedef {module:graphTheory.Graph} Graph */ × Search results Close "},"graphTheory.js.html":{"id":"graphTheory.js.html","title":"Source: graphTheory.js","body":" DocStrap Modules graphTheory Classes graphTheory.EdgegraphTheory.EdgeArraygraphTheory.EdgeComponentgraphTheory.GraphgraphTheory.NodegraphTheory.NodeArraygraphTheory.Vertex Global Global Source: graphTheory.js /** * @module graphTheory */ exports.Vertex = require('./graphTheory/vertex'); exports.Node = require('./graphTheory/node'); exports.NodeArray = require('./graphTheory/nodeArray'); exports.DirectedEdge = require('./graphTheory/directedEdge'); exports.Edge = require('./graphTheory/edge'); exports.EdgeArray = require('./graphTheory/edgeArray'); exports.Graph = require('./graphTheory/graph'); exports.Component = require('./graphTheory/component'); exports.EdgeComponent = require('./graphTheory/edgeComponent'); × Search results Close "},"graphTheory_node.js.html":{"id":"graphTheory_node.js.html","title":"Source: graphTheory/node.js","body":" DocStrap Modules graphTheory Classes graphTheory.EdgegraphTheory.EdgeArraygraphTheory.EdgeComponentgraphTheory.GraphgraphTheory.NodegraphTheory.NodeArraygraphTheory.Vertex Global Global Source: graphTheory/node.js /** * represent a Node * @exports Node * @constructor * @memberOf module:graphTheory * @param {String} [label = 'default'] [label property]{@link module:graphTheory.Node#label} * @param {Object} data the nodes data */ class Node { constructor(label, data) { /** * the node identifier * @type {String} */ this.label = label; /** * the node data * @type {Object} */ this.data = data; } /** * Checks for identity via label attribute * @param {Node} newNode the node to be compared * @return {Boolean} */ isIdentical(newNode) { return (this.label) ? this.label == newNode.label : false; } } module.exports = Node; /** * [A Node]{@link module:graphTheory.Node} * @typedef {module:graphTheory.Node} Node */ × Search results Close "},"graphTheory_nodeArray.js.html":{"id":"graphTheory_nodeArray.js.html","title":"Source: graphTheory/nodeArray.js","body":" DocStrap Modules graphTheory Classes graphTheory.EdgegraphTheory.EdgeArraygraphTheory.EdgeComponentgraphTheory.GraphgraphTheory.NodegraphTheory.NodeArraygraphTheory.Vertex Global Global Source: graphTheory/nodeArray.js var Node = require('./node'); /** * represents a set of Nodes * @exports NodeArray * @constructor * @memberOf! module:graphTheory */ class NodeArray extends Array { /** * checks for presence of node in this set * @param {Node} argNode [description] * @return {Boolean} */ contains(argNode) { return this.some(el =&gt; (el.isIdentical(argNode) === true)); } /** * checks type of argument for Node status * @param {Node} argNode * @return {Boolean} */ isNode(argNode) { return argNode instanceof Node; } /** * adds a node to this set * @param {Node} argNode * @return {Boolean} */ push(argNode) { return (this.isNode(argNode) &amp;&amp; !(this.contains(argNode))) ? super.push(argNode) : false; } /** * returns an array shared nodes between two sets * @param {NodeArray} altArray the array to check * @return {NodeArray} the shared nodes */ intersection(altArray) { return this.filter(currNode =&gt; altArray.contains(currNode) === true); } /** * checks for presence of shared nodes between two sets * @param {NodeArray} altArray the array to check * @return {Boolean} */ intersects(altArray) { return this.some(currNode =&gt; altArray.contains(currNode) === true); } /** * returns an array nodes in this array not included in the alternate array * @param {NodeArray} altArray the array to check * @return {NodeArray} the unshared nodes */ difference(altArray) { let diffArray = new NodeArray(); this.reduce((dArray, currNode) =&gt; { if (!altArray.contains(currNode)) dArray.push(currNode); return dArray; }, diffArray); altArray.reduce((dArray, altNode) =&gt; { if (!this.contains(altNode)) dArray.push(altNode); return dArray; }, diffArray); return diffArray; } /** * checks for presence of unshared nodes between two sets * @param {NodeArray} altArray the array to check * @return {Boolean} */ hasDistinctNodes(altArray) { return altArray.some(altNode =&gt; !this.contains(altNode)); } /** * returns a combined array of nodes belonging to this and the alternate arrays * @param {NodeArray} altArray the array to combine * @return {NodeArray} the nodes */ union(altArray) { let uArray = new NodeArray(); this.forEach(currNode =&gt; uArray.push(currNode)); altArray.forEach(altNode =&gt; uArray.push(altNode)); return uArray; } /** * combines all the nodes into this nodeArray * @param {NodeArray} altArray the array to check */ unionize(altArray) { this.difference(altArray).forEach(dNode =&gt; this.push(dNode)); } } module.exports = NodeArray; /** * [A NodeArray]{@link module:graphTheory.NodeArray} * @typedef {module:graphTheory.NodeArray} NodeArray */ × Search results Close "},"graphTheory_vertex.js.html":{"id":"graphTheory_vertex.js.html","title":"Source: graphTheory/vertex.js","body":" DocStrap Modules graphTheory Classes graphTheory.EdgegraphTheory.EdgeArraygraphTheory.EdgeComponentgraphTheory.GraphgraphTheory.NodegraphTheory.NodeArraygraphTheory.Vertex Global Global Source: graphTheory/vertex.js /** * represent a Vertex * @exports Vertex * @constructor * @memberOf module:graphTheory * @param {String} [label = 'default'] [label property]{@link module:graphTheory.Vertex#label} */ module.exports = function Vertex(label = 'default') { /** * the vertex identifier * @type {String} */ this.label = label; }; /** * [A Vertex]{@link module:graphTheory.Vertex} * @typedef {module:graphTheory.Vertex} Vertex */ × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" DocStrap Modules graphTheory Classes graphTheory.EdgegraphTheory.EdgeArraygraphTheory.EdgeComponentgraphTheory.GraphgraphTheory.NodegraphTheory.NodeArraygraphTheory.Vertex Global Global Global Type Definitions Edge An Edge Type: module:graphTheory.Edge Source: graphTheory/edge.js, line 54 EdgeArray An EdgeArray Type: module:graphTheory.EdgeArray Source: graphTheory/edgeArray.js, line 113 EdgeComponent An EdgeComponent Type: module:graphTheory.EdgeComponent Source: graphTheory/edgeComponent.js, line 126 Graph A Graph Type: module:graphTheory.Graph Source: graphTheory/graph.js, line 285 Node A Node Type: module:graphTheory.Node Source: graphTheory/node.js, line 34 NodeArray A NodeArray Type: module:graphTheory.NodeArray Source: graphTheory/nodeArray.js, line 100 Vertex A Vertex Type: module:graphTheory.Vertex Source: graphTheory/vertex.js, line 16 × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" DocStrap Modules graphTheory Classes graphTheory.EdgegraphTheory.EdgeArraygraphTheory.EdgeComponentgraphTheory.GraphgraphTheory.NodegraphTheory.NodeArraygraphTheory.Vertex Global Global Modules Classes Edge EdgeArray EdgeComponent Graph Node NodeArray Vertex × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" DocStrap Modules graphTheory Classes graphTheory.EdgegraphTheory.EdgeArraygraphTheory.EdgeComponentgraphTheory.GraphgraphTheory.NodegraphTheory.NodeArraygraphTheory.Vertex Global Global Classes Classes Edge EdgeArray EdgeComponent Graph Node NodeArray Vertex × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" DocStrap Modules graphTheory Classes graphTheory.EdgegraphTheory.EdgeArraygraphTheory.EdgeComponentgraphTheory.GraphgraphTheory.NodegraphTheory.NodeArraygraphTheory.Vertex Global Global × Search results Close "},"module-graphTheory.html":{"id":"module-graphTheory.html","title":"Module: graphTheory","body":" DocStrap Modules graphTheory Classes graphTheory.EdgegraphTheory.EdgeArraygraphTheory.EdgeComponentgraphTheory.GraphgraphTheory.NodegraphTheory.NodeArraygraphTheory.Vertex Global Global Module: graphTheory Source: graphTheory.js, line 1 Classes Edge EdgeArray EdgeComponent Graph Node NodeArray Vertex × Search results Close "},"module-graphTheory.Edge.html":{"id":"module-graphTheory.Edge.html","title":"Class: Edge","body":" DocStrap Modules graphTheory Classes graphTheory.EdgegraphTheory.EdgeArraygraphTheory.EdgeComponentgraphTheory.GraphgraphTheory.NodegraphTheory.NodeArraygraphTheory.Vertex Global Global Class: Edge graphTheory. Edge represents a connection between nodes new Edge() Source: graphTheory/edge.js, line 10 Methods containsNode(nodeArg) Checks for presence fo a node in this edge Parameters: Name Type Description nodeArg Node Source: graphTheory/edge.js, line 41 Returns: Type Node getNeighbor(nodeArg) returns the neighboring node Parameters: Name Type Description nodeArg Node Source: graphTheory/edge.js, line 49 Returns: the neighbor Type Node isEquivalent(edgeArg) checks the equivalence (by label)of this edge against another Parameters: Name Type Description edgeArg Edge edge to be checked Source: graphTheory/edge.js, line 33 Returns: Type Boolean × Search results Close "},"module-graphTheory.EdgeArray.html":{"id":"module-graphTheory.EdgeArray.html","title":"Class: EdgeArray","body":" DocStrap Modules graphTheory Classes graphTheory.EdgegraphTheory.EdgeArraygraphTheory.EdgeComponentgraphTheory.GraphgraphTheory.NodegraphTheory.NodeArraygraphTheory.Vertex Global Global Class: EdgeArray graphTheory. EdgeArray represents a set of Edges new EdgeArray() Source: graphTheory/edgeArray.js, line 11 Methods contains(argEdge) checks for presence of edge in this set Parameters: Name Type Description argEdge Edge [description] Source: graphTheory/edgeArray.js, line 17 Returns: Type Boolean difference(altArray) returns an array edges in this array not included in the alternate array Parameters: Name Type Description altArray EdgeArray the array to check Source: graphTheory/edgeArray.js, line 69 Returns: the unshared edges Type EdgeArray getNodes() assembles each edges nodes into one large array Source: graphTheory/edgeArray.js, line 40 Returns: Type NodeArray hasDistinctEdges(altArray) checks for presence of unshared edges between two sets Parameters: Name Type Description altArray EdgeArray the array to check Source: graphTheory/edgeArray.js, line 88 Returns: Type Boolean intersection(altArray) returns an array shared edges between two sets Parameters: Name Type Description altArray EdgeArray the array to check Source: graphTheory/edgeArray.js, line 52 Returns: the shared edges Type EdgeArray intersects(altArray) checks for presence of shared edges between two sets Parameters: Name Type Description altArray EdgeArray the array to check Source: graphTheory/edgeArray.js, line 61 Returns: Type Boolean isEdge(argEdge) checks type of argument for Edge status Parameters: Name Type Description argEdge Edge Source: graphTheory/edgeArray.js, line 25 Returns: Type Boolean push(argEdge) adds a edge to this set Parameters: Name Type Description argEdge Edge Source: graphTheory/edgeArray.js, line 33 Returns: Type Boolean union(altArray) returns a combined array of edges belonging to this and the alternate arrays Parameters: Name Type Description altArray EdgeArray the array to combine Source: graphTheory/edgeArray.js, line 96 Returns: the edges Type EdgeArray unionize(altArray) combines all the edges into this edgeArray Parameters: Name Type Description altArray EdgeArray the array to check Source: graphTheory/edgeArray.js, line 107 × Search results Close "},"module-graphTheory.EdgeComponent.html":{"id":"module-graphTheory.EdgeComponent.html","title":"Class: EdgeComponent","body":" DocStrap Modules graphTheory Classes graphTheory.EdgegraphTheory.EdgeArraygraphTheory.EdgeComponentgraphTheory.GraphgraphTheory.NodegraphTheory.NodeArraygraphTheory.Vertex Global Global Class: EdgeComponent graphTheory. EdgeComponent represents a set of Connected Edges new EdgeComponent() Source: graphTheory/edgeComponent.js, line 11 Methods addEdge(edgeArg) adds an edge and its nodes to this component Parameters: Name Type Description edgeArg Edge [description] Source: graphTheory/edgeComponent.js, line 71 containsEdge(edgeArg) checks for presence of an edge in this component Parameters: Name Type Description edgeArg Edge Source: graphTheory/edgeComponent.js, line 56 Returns: Type Boolean containsNode(nodeArg) checks this component for the presence of a node Parameters: Name Type Description nodeArg Node Source: graphTheory/edgeComponent.js, line 64 Returns: Type Boolean difference(compArg) returns an array nodes in this array not included in the alternate array Parameters: Name Type Description compArg Component the component to check Source: graphTheory/edgeComponent.js, line 103 Returns: the unshared nodes Type NodeArray getNodes() composes all of the edges nodes into one large array Source: graphTheory/edgeComponent.js, line 40 Returns: Type NodeArray intersection(compArg) returns an array shared nodes between two components Parameters: Name Type Description compArg Component the component to check Source: graphTheory/edgeComponent.js, line 95 Returns: the shared edges Type EdgeArray intersects(compArg) returns an array shared edges between two sets Parameters: Name Type Description compArg Component the component to check Source: graphTheory/edgeComponent.js, line 87 Returns: the shared edges Type EdgeArray nodeMap() gets the nodes of each edge Source: graphTheory/edgeComponent.js, line 79 Returns: Type NodeArray resetArity() sets the arity to the length of the nodes array Source: graphTheory/edgeComponent.js, line 33 union(compArg) returns a combined array of edges belonging to this and the alternate arrays Parameters: Name Type Description compArg Component the component to check Source: graphTheory/edgeComponent.js, line 111 Returns: the edges Type EdgeArray unionize(compArg) combines all the edges into this Component Parameters: Name Type Description compArg Component the component to check Source: graphTheory/edgeComponent.js, line 118 updateNodes() resets the nodes array based on the edges Source: graphTheory/edgeComponent.js, line 46 × Search results Close "},"module-graphTheory.Graph.html":{"id":"module-graphTheory.Graph.html","title":"Class: Graph","body":" DocStrap Modules graphTheory Classes graphTheory.EdgegraphTheory.EdgeArraygraphTheory.EdgeComponentgraphTheory.GraphgraphTheory.NodegraphTheory.NodeArraygraphTheory.Vertex Global Global Class: Graph graphTheory. Graph represents a Graph new Graph() Source: graphTheory/graph.js, line 13 Methods addComponent(compArg) adds a component to the graph if not present Parameters: Name Type Description compArg Component [description] Source: graphTheory/graph.js, line 110 addEdge(sNode, dNode, weight) creates a new edge given two nodes Parameters: Name Type Description sNode Node source node dNode Node destination node weight Number weight of new edge Source: graphTheory/graph.js, line 44 addNode(node) adds a node to the nodes array, if not already contained Parameters: Name Type Description node Node the new node Source: graphTheory/graph.js, line 35 bfs(initNode) breadth first search, recursively adds all immediate neighbors, to a component of nodes reachabe by a initial node Parameters: Name Type Description initNode Node inital node Source: graphTheory/graph.js, line 174 Returns: a key-value store of nodes and edge distances Type Map depthTraverse(initNode) depth first search, initializes a new component of reachable nodes, and constructs a path to each of those node from the source Parameters: Name Type Description initNode Node inital node Source: graphTheory/graph.js, line 94 Returns: a key-value store of nodes and edge distances Type Component dijkstra(initNode, termNode) performs dijkstras algorithm for shortest paths to all nodes reachabe from initNode Parameters: Name Type Description initNode Node the initial node termNode Node the terminal node Source: graphTheory/graph.js, line 223 Returns: a shortest path between nodes Type Object findIntersectingComponent(compArg) returns any current components which intersect with the specified component Parameters: Name Type Description compArg Component the component to be checked Source: graphTheory/graph.js, line 118 Returns: the first intersecting component Type Component getEdges(nodeArg) Parameters: Name Type Description nodeArg Node source node Source: graphTheory/graph.js, line 52 Returns: the edges connected to source Type Array.&lt;Edge&gt; getNeighbors(nodeArg) Parameters: Name Type Description nodeArg Node the source node Source: graphTheory/graph.js, line 60 Returns: the neighboring nodes Type Array.&lt;Node&gt; getUnvisitedEdges(nodeArg, compArg) returns all of the nodes Edges which contain nodes not yet in the specified component Parameters: Name Type Description nodeArg Node [description] compArg Component [description] Source: graphTheory/graph.js, line 152 Returns: [description] Type EdgeArray getUnvisitedNeighbors(nodeArg, compArg) returns all of the nodes neighbors not yet part od the component Parameters: Name Type Description nodeArg Node [description] compArg Component [description] Source: graphTheory/graph.js, line 164 Returns: [description] Type NodeArray hasIntersectingComponent(compArg) checks if any current components share nodes with the argument Parameters: Name Type Description compArg Component [description] Source: graphTheory/graph.js, line 143 Returns: [description] Type Boolean hasPath(initNode, termNode) check if a path exists between two nodes Parameters: Name Type Description initNode Node the initial node termNode Node the terminal node Source: graphTheory/graph.js, line 213 Returns: a path exists between the two nodes Type Boolean integrateComponent(compArg) integrates a component into any of the graphs intersectung components Parameters: Name Type Description compArg Component [description] Source: graphTheory/graph.js, line 134 mergeComponents(origComp, newComp) combines the nodes of two intersecting components Parameters: Name Type Description origComp Component newComp Component Source: graphTheory/graph.js, line 127 shortestPath(initNode, termNode) composes the shortest path between two nodes by backtracing dijkstra's pred attirbute Parameters: Name Type Description initNode Node [description] termNode Node [description] Source: graphTheory/graph.js, line 262 Returns: path of nodes Type Map visitComponent(pathArg, compArg) adds all unvisited nodes in the path to the specified component adds each node connected to an edge to a (depth) path Parameters: Name Type Description pathArg Map the path to be explored compArg Component a key value store of node's and distances Source: graphTheory/graph.js, line 69 × Search results Close "},"module-graphTheory.Node.html":{"id":"module-graphTheory.Node.html","title":"Class: Node","body":" DocStrap Modules graphTheory Classes graphTheory.EdgegraphTheory.EdgeArraygraphTheory.EdgeComponentgraphTheory.GraphgraphTheory.NodegraphTheory.NodeArraygraphTheory.Vertex Global Global Class: Node graphTheory. Node represent a Node new Node( [label], data) Parameters: Name Type Argument Default Description label String &lt;optional&gt; 'default' label property data Object the nodes data Source: graphTheory/node.js, line 9 Methods isIdentical(newNode) Checks for identity via label attribute Parameters: Name Type Description newNode Node the node to be compared Source: graphTheory/node.js, line 28 Returns: Type Boolean × Search results Close "},"module-graphTheory.NodeArray.html":{"id":"module-graphTheory.NodeArray.html","title":"Class: NodeArray","body":" DocStrap Modules graphTheory Classes graphTheory.EdgegraphTheory.EdgeArraygraphTheory.EdgeComponentgraphTheory.GraphgraphTheory.NodegraphTheory.NodeArraygraphTheory.Vertex Global Global Class: NodeArray graphTheory. NodeArray represents a set of Nodes new NodeArray() Source: graphTheory/nodeArray.js, line 8 Methods contains(argNode) checks for presence of node in this set Parameters: Name Type Description argNode Node [description] Source: graphTheory/nodeArray.js, line 14 Returns: Type Boolean difference(altArray) returns an array nodes in this array not included in the alternate array Parameters: Name Type Description altArray NodeArray the array to check Source: graphTheory/nodeArray.js, line 54 Returns: the unshared nodes Type NodeArray hasDistinctNodes(altArray) checks for presence of unshared nodes between two sets Parameters: Name Type Description altArray NodeArray the array to check Source: graphTheory/nodeArray.js, line 74 Returns: Type Boolean intersection(altArray) returns an array shared nodes between two sets Parameters: Name Type Description altArray NodeArray the array to check Source: graphTheory/nodeArray.js, line 38 Returns: the shared nodes Type NodeArray intersects(altArray) checks for presence of shared nodes between two sets Parameters: Name Type Description altArray NodeArray the array to check Source: graphTheory/nodeArray.js, line 46 Returns: Type Boolean isNode(argNode) checks type of argument for Node status Parameters: Name Type Description argNode Node Source: graphTheory/nodeArray.js, line 22 Returns: Type Boolean push(argNode) adds a node to this set Parameters: Name Type Description argNode Node Source: graphTheory/nodeArray.js, line 30 Returns: Type Boolean union(altArray) returns a combined array of nodes belonging to this and the alternate arrays Parameters: Name Type Description altArray NodeArray the array to combine Source: graphTheory/nodeArray.js, line 82 Returns: the nodes Type NodeArray unionize(altArray) combines all the nodes into this nodeArray Parameters: Name Type Description altArray NodeArray the array to check Source: graphTheory/nodeArray.js, line 92 × Search results Close "},"module-graphTheory.Vertex.html":{"id":"module-graphTheory.Vertex.html","title":"Class: Vertex","body":" DocStrap Modules graphTheory Classes graphTheory.EdgegraphTheory.EdgeArraygraphTheory.EdgeComponentgraphTheory.GraphgraphTheory.NodegraphTheory.NodeArraygraphTheory.Vertex Global Global Class: Vertex graphTheory. Vertex new Vertex( [label]) represent a Vertex Parameters: Name Type Argument Default Description label String &lt;optional&gt; 'default' label property Source: graphTheory/vertex.js, line 8 Members label :String the vertex identifier Type: String Source: graphTheory/vertex.js, line 13 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
